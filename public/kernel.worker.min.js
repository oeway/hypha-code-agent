/*! For license information please see kernel.worker.min.js.LICENSE.txt */
var e={590:(e,t,r)=>{r.d(t,{BX:()=>R,LV:()=>d,p:()=>u});const n=Symbol("Comlink.proxy"),s=Symbol("Comlink.endpoint"),o=Symbol("Comlink.releaseProxy"),i=Symbol("Comlink.finalizer"),a=Symbol("Comlink.thrown"),c=e=>"object"==typeof e&&null!==e||"function"==typeof e,l=new Map([["proxy",{canHandle:e=>c(e)&&e[n],serialize(e){const{port1:t,port2:r}=new MessageChannel;return u(e,t),[r,[r]]},deserialize:e=>(e.start(),d(e))}],["throw",{canHandle:e=>c(e)&&a in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function u(e,t=globalThis,r=["*"]){t.addEventListener("message",function n(s){if(!s||!s.data)return;if(!function(e,t){for(const r of e){if(t===r||"*"===r)return!0;if(r instanceof RegExp&&r.test(t))return!0}return!1}(r,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:o,type:c,path:l}=Object.assign({path:[]},s.data),d=(s.data.argumentList||[]).map(b);let m;try{const t=l.slice(0,-1).reduce((e,t)=>e[t],e),r=l.reduce((e,t)=>e[t],e);switch(c){case"GET":m=r;break;case"SET":t[l.slice(-1)[0]]=b(s.data.value),m=!0;break;case"APPLY":m=r.apply(t,d);break;case"CONSTRUCT":m=R(new r(...d));break;case"ENDPOINT":{const{port1:t,port2:r}=new MessageChannel;u(e,r),m=function(e,t){return w.set(e,t),e}(t,[t])}break;case"RELEASE":m=void 0;break;default:return}}catch(e){m={value:e,[a]:0}}Promise.resolve(m).catch(e=>({value:e,[a]:0})).then(r=>{const[s,a]=_(r);t.postMessage(Object.assign(Object.assign({},s),{id:o}),a),"RELEASE"===c&&(t.removeEventListener("message",n),p(t),i in e&&"function"==typeof e[i]&&e[i]())}).catch(e=>{const[r,n]=_({value:new TypeError("Unserializable return value"),[a]:0});t.postMessage(Object.assign(Object.assign({},r),{id:o}),n)})}),t.start&&t.start()}function p(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function d(e,t){const r=new Map;return e.addEventListener("message",function(e){const{data:t}=e;if(!t||!t.id)return;const n=r.get(t.id);if(n)try{n(t)}finally{r.delete(t.id)}}),g(e,r,[],t)}function m(e){if(e)throw new Error("Proxy has been released and is not useable")}function y(e){return k(e,new Map,{type:"RELEASE"}).then(()=>{p(e)})}const h=new WeakMap,f="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(h.get(e)||0)-1;h.set(e,t),0===t&&y(e)});function g(e,t,r=[],n=function(){}){let i=!1;const a=new Proxy(n,{get(n,s){if(m(i),s===o)return()=>{!function(e){f&&f.unregister(e)}(a),y(e),t.clear(),i=!0};if("then"===s){if(0===r.length)return{then:()=>a};const n=k(e,t,{type:"GET",path:r.map(e=>e.toString())}).then(b);return n.then.bind(n)}return g(e,t,[...r,s])},set(n,s,o){m(i);const[a,c]=_(o);return k(e,t,{type:"SET",path:[...r,s].map(e=>e.toString()),value:a},c).then(b)},apply(n,o,a){m(i);const c=r[r.length-1];if(c===s)return k(e,t,{type:"ENDPOINT"}).then(b);if("bind"===c)return g(e,t,r.slice(0,-1));const[l,u]=E(a);return k(e,t,{type:"APPLY",path:r.map(e=>e.toString()),argumentList:l},u).then(b)},construct(n,s){m(i);const[o,a]=E(s);return k(e,t,{type:"CONSTRUCT",path:r.map(e=>e.toString()),argumentList:o},a).then(b)}});return function(e,t){const r=(h.get(t)||0)+1;h.set(t,r),f&&f.register(e,t,e)}(a,e),a}function E(e){const t=e.map(_);return[t.map(e=>e[0]),(r=t.map(e=>e[1]),Array.prototype.concat.apply([],r))];var r}const w=new WeakMap;function R(e){return Object.assign(e,{[n]:!0})}function _(e){for(const[t,r]of l)if(r.canHandle(e)){const[n,s]=r.serialize(e);return[{type:"HANDLER",name:t,value:n},s]}return[{type:"RAW",value:e},w.get(e)||[]]}function b(e){switch(e.type){case"HANDLER":return l.get(e.name).deserialize(e.value);case"RAW":return e.value}}function k(e,t,r,n){return new Promise(s=>{const o=new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-");t.set(o,s),e.start&&e.start(),e.postMessage(Object.assign({id:o},r),n)})}},637:(e,t,r)=>{r.d(t,{MB:()=>u});const n="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js";let s=!1,o=null;var i,a,c=r(696);r(590),function(e){e.MAIN_THREAD="main_thread",e.WORKER="worker"}(i||(i={})),function(e){e.PYTHON="python"}(a||(a={}));class l{constructor(){this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}off(e,t){if(!this.events[e])return;const r=this.events[e].indexOf(t);r>-1&&this.events[e].splice(r,1)}emit(e,...t){this.events[e]&&this.events[e].forEach(e=>e(...t))}setMaxListeners(e){}}class u extends l{constructor(){super(),this.initialized=!1,this.initPromise=null,this.filesystemOptions={enabled:!1,root:".",mountPoint:"/home/pyodide"},this._resolveInputReply=null,this._parent_header={},this.executionCount=0,this._status="unknown",this._interruptBuffer=null,this._interruptSupported=!1,this.environmentVariables={},this.nativeFsHandles=new Map,this.autoSyncFs=!1,super.setMaxListeners(20),this.kernelId=`kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`}async getStatus(){return this._status}async initialize(e){if(!this.initialized)return this.initPromise||(e?.filesystem&&(this.filesystemOptions={...this.filesystemOptions,...e.filesystem}),e?.env&&(this.environmentVariables={...e.env}),e?.lockFileURL&&(this.lockFileURL=e.lockFileURL),void 0!==e?.autoSyncFs&&(this.autoSyncFs=e.autoSyncFs),this.initPromise=this._initializeInternal()),this.initPromise}async _initializeInternal(){const e=Date.now();console.log("ðŸš€ Starting optimized kernel initialization...");try{const t=Date.now(),r={};this.lockFileURL&&(r.lockFileURL=this.lockFileURL,console.log(`ðŸ”’ Using lockFileURL: ${this.lockFileURL}`)),this.pyodide=await async function(e={}){return o||(o=(async()=>{try{"undefined"!=typeof importScripts?await new Promise((e,t)=>{try{if("undefined"==typeof importScripts)return void t(new Error("importScripts is not available - not in a worker context"));if(void 0!==globalThis.loadPyodide)return void e();importScripts(n),e()}catch(e){t(new Error(`Failed to import Pyodide in worker: ${e}`))}}):await new Promise((e,t)=>{if(void 0!==globalThis.loadPyodide)return void e();const r=document.createElement("script");r.src=n,r.onload=()=>e(),r.onerror=()=>t(new Error(`Failed to load Pyodide from ${n}`)),document.head.appendChild(r)});const t=globalThis.loadPyodide;if(!t)throw new Error("loadPyodide function not found after script load");const r={indexURL:"https://cdn.jsdelivr.net/pyodide/v0.28.0/full/",...e},o=await t(r);return s=!0,console.log("âœ… Pyodide loaded successfully from CDN"),o}catch(e){throw o=null,e}})(),o)}(r);const i=Date.now()-t;if(console.log(`âœ… Pyodide loaded in ${i}ms`),this.lockFileURL){console.log("ðŸš€ Using lock file - skipping package installation");const[,]=await Promise.all([this.filesystemOptions.enabled?this.mountFileSystem():Promise.resolve(),this.setEnvironmentVariables()]);await this.initGlobals()}else{const[,,]=await Promise.all([this.filesystemOptions.enabled?this.mountFileSystem():Promise.resolve(),this.initPackageManager(),this.setEnvironmentVariables()]);await this.initKernel(),await this.initGlobals()}const a=Date.now()-e;console.log(`ðŸŽ¯ KERNEL INITIALIZATION COMPLETE in ${a}ms`),console.log(`âš¡ Performance: Pyodide(${i}ms) + Setup(${a-i}ms)`),this.initialized=!0,this._status="active",console.log("ðŸŸ¢ Kernel is now ACTIVE and ready for execution!")}catch(e){throw console.error("âŒ Kernel initialization failed:",e),this._status="unknown",e}}async mountFileSystem(){try{console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`),await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS,{root:this.filesystemOptions.root||"."},this.filesystemOptions.mountPoint||"/home/pyodide"),console.log("FileSystem mounted successfully");try{const e=this.pyodide.FS.readdir(this.filesystemOptions.mountPoint||"/home/pyodide");console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${e.join(", ")}`)}catch(e){console.error(`Error listing mounted directory: ${e}`)}}catch(e){throw console.error("Error mounting filesystem:",e),e}}async initPackageManager(){const e=Date.now();console.log("âš¡ Initializing optimized package manager...");try{let t;console.log("ðŸ“¦ Loading micropip, packaging..."),await this.pyodide.loadPackage(["micropip","packaging"]),console.log("âœ… Loaded micropip, packaging"),t="undefined"!=typeof window&&window.location?new URL(".",window.location.href).href:"undefined"!=typeof self&&self.location?new URL(".",self.location.href).href:"/";const r=new URL("pypi/all.json",t).href,n=[new URL("pypi/piplite-0.6.0a5-py3-none-any.whl",t).href,new URL("pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl",t).href,new URL("pypi/ipykernel-6.9.2-py3-none-any.whl",t).href,new URL("pypi/widgetsnbextension-3.6.999-py3-none-any.whl",t).href,new URL("pypi/widgetsnbextension-4.0.999-py3-none-any.whl",t).href];console.log(`ðŸš€ Installing ${n.length} wheel packages in parallel...`);const s=n.map(async(e,t)=>{const r=Date.now();try{await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${e}', keep_going=True)\nprint(f"âœ… Wheel ${t+1}/${n.length} installed")\n`);const s=Date.now()-r;return console.log(`âš¡ Wheel ${t+1} installed in ${s}ms`),{index:t,success:!0,time:s}}catch(e){const n=Date.now()-r;return console.warn(`âš ï¸ Wheel ${t+1} failed after ${n}ms:`,e),{index:t,success:!1,time:n,error:e}}}),o=await Promise.all(s),i=o.filter(e=>e.success),a=o.filter(e=>!e.success);console.log(`ðŸ“Š Wheels: ${i.length}/${n.length} successful`),a.length>0&&console.warn(`âš ï¸ Failed wheels: ${a.map(e=>e.index+1).join(", ")}`);try{await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = "${r}"\n        # Pre-load package index for faster installation\n        print("ðŸ“‹ Package index configured")\n    except Exception as e:\n        print(f"âš ï¸ Package index setup warning: {e}")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print("âš¡ Piplite optimized for performance")\nexcept ImportError:\n    print("âš ï¸ Piplite not available, continuing without it")\nexcept Exception as e:\n    print(f"âš ï¸ Piplite setup failed: {e}")\n`)}catch(e){console.warn("âš ï¸ Piplite configuration failed, continuing without it:",e)}const c=Date.now()-e;console.log(`ðŸŽ¯ Package manager initialized in ${c}ms`)}catch(e){throw console.error("âŒ Package manager initialization failed:",e),e}}async initKernel(){const e=Date.now();console.log("ðŸš€ Initializing kernel packages with maximum optimization...");const t=[{name:"pure-eval",priority:1,source:"pyodide"},{name:"stack-data",priority:1,source:"pyodide"},{name:"pygments",priority:1,source:"pyodide"},{name:"ssl",priority:1,source:"pyodide"},{name:"sqlite3",priority:1,source:"pyodide"},{name:"prompt_toolkit",priority:1,source:"pyodide"},{name:"jedi",priority:1,source:"pyodide"},{name:"ipython",priority:1,source:"pyodide"},{name:"comm",priority:2,source:"pip"},{name:"hypha-rpc",priority:2,source:"pip"},{name:"nbformat",priority:2,source:"pip"},{name:"ipykernel",priority:3,source:"pip"},{name:"pyodide_kernel",priority:3,source:"pip"}];try{console.log(`ðŸ“¦ Installing ${t.length} packages with intelligent optimization...`),await this.installPackagesWithIntelligentOptimization(t),console.log("ðŸ“¥ Importing pyodide_kernel...");const r=Date.now();await this.pyodide.runPythonAsync("import pyodide_kernel");const n=Date.now()-r;console.log(`âœ… pyodide_kernel imported in ${n}ms`);const s=Date.now()-e;console.log(`ðŸŽ¯ Kernel packages initialized in ${s}ms`)}catch(e){throw console.error("âŒ Kernel package initialization failed:",e),e}}async installPackagesWithIntelligentOptimization(e){console.log(`âš¡ Starting intelligent parallel installation of ${e.length} packages...`);const t=e.map(async e=>{const t=Date.now();try{if(console.log(`ðŸ”„ Installing ${e.name} (priority: ${e.priority}, preferred: ${e.source})...`),"pyodide"!==e.source){await this.installViaPipWithOptimizations(e.name);const r=Date.now()-t;return console.log(`âœ… ${e.name} installed via pip (${r}ms)`),{package:e.name,method:"pip",duration:r,success:!0,priority:e.priority}}try{await this.pyodide.loadPackage([e.name]);const r=Date.now()-t;return console.log(`âœ… ${e.name} loaded from Pyodide CDN (${r}ms)`),{package:e.name,method:"pyodide",duration:r,success:!0,priority:e.priority}}catch(r){console.log(`ðŸ“¦ ${e.name} not available on CDN, trying pip...`),await this.installViaPipWithOptimizations(e.name);const n=Date.now()-t;return console.log(`âœ… ${e.name} installed via pip fallback (${n}ms)`),{package:e.name,method:"pip-fallback",duration:n,success:!0,priority:e.priority}}}catch(r){const n=Date.now()-t;return console.warn(`âŒ Failed to install ${e.name} after ${n}ms:`,r),{package:e.name,method:"failed",duration:n,success:!1,priority:e.priority,error:r}}}),r=await Promise.all(t);this.analyzeInstallationResults(r)}async installViaPipWithOptimizations(e){await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${e}', keep_going=True, deps=True)\n    print("âœ… Successfully installed ${e} via optimized pip")\nexcept Exception as e:\n    print("âš ï¸ Warning: Failed to install ${e}:", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${e}', keep_going=True)\n        print("âœ… Successfully installed ${e} via micropip fallback")\n    except Exception as e2:\n        print("âŒ Both pip methods failed for ${e}:", str(e2))\n        raise e2\n`)}analyzeInstallationResults(e){const t=e.filter(e=>e.success),r=e.filter(e=>!e.success),n=t.filter(e=>"pyodide"===e.method),s=t.filter(e=>"pip"===e.method),o=t.filter(e=>"pip-fallback"===e.method),i=Math.max(...e.map(e=>e.duration)),a=e.reduce((e,t)=>e+t.duration,0)/e.length,c=e.reduce((e,t)=>e+t.duration,0);console.log("ðŸŽ¯ INTELLIGENT INSTALLATION COMPLETE!"),console.log(`ðŸ“Š Results: ${t.length}/${e.length} successful`),console.log(`âš¡ Pyodide CDN: ${n.length} packages`),console.log(`ðŸ“¦ Direct pip: ${s.length} packages`),console.log(`ðŸ”„ Pip fallback: ${o.length} packages`),console.log(`âŒ Failed: ${r.length} packages`),console.log(`â±ï¸  Total time: ${i}ms (vs ~${c}ms sequential)`),console.log(`ðŸš€ Speed improvement: ~${Math.round(c/i)}x faster`),console.log(`ðŸ“ˆ Average per package: ${Math.round(a)}ms`),r.length>0&&(console.warn(`âš ï¸  Failed packages: ${r.map(e=>e.package).join(", ")}`),r.forEach(e=>{console.warn(`   - ${e.package}: ${e.error?.message||"Unknown error"}`)}));const l=Math.min(...t.map(e=>e.duration)),u=Math.max(...t.map(e=>e.duration));console.log(`ðŸ“Š Performance range: ${l}ms (fastest) to ${u}ms (slowest)`)}async initGlobals(){console.log("Initializing globals...");const{globals:e}=this.pyodide;this._kernel=e.get("pyodide_kernel").kernel_instance.copy(),this._stdout_stream=e.get("pyodide_kernel").stdout_stream.copy(),this._stderr_stream=e.get("pyodide_kernel").stderr_stream.copy(),this._interpreter=this._kernel.interpreter.copy(),this._interpreter.send_comm=this.sendComm.bind(this),this.setupCallbacks()}setupCallbacks(){const e=(e,t)=>{const r={name:this.formatResult(e),text:this.formatResult(t)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:r,type:"stream"})};this._stdout_stream.publish_stream_callback=e,this._stderr_stream.publish_stream_callback=e,this._interpreter.display_pub.clear_output_callback=e=>{const t={wait:this.formatResult(e)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:t,type:"clear_output"})},this._interpreter.display_pub.display_data_callback=(e,t,r)=>{const n={data:this.formatResult(e),metadata:this.formatResult(t),transient:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"display_data"})},this._interpreter.display_pub.update_display_data_callback=(e,t,r)=>{const n={data:this.formatResult(e),metadata:this.formatResult(t),transient:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"update_display_data"})},this._interpreter.displayhook.publish_execution_result=(e,t,r)=>{const n={execution_count:e,data:this.formatResult(t),metadata:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"execute_result"})},this._interpreter.input=this.input.bind(this),this._interpreter.getpass=this.getpass.bind(this)}_sendMessage(e){this._processMessage(e)}_processMessage(e){if(!e.type)return;let t;switch(e.type){case"stream":{const r=e.bundle??{name:"stdout",text:""};super.emit(c.z.STREAM,r),t=r;break}case"input_request":{const r=e.content??{prompt:"",password:!1};super.emit(c.z.INPUT_REQUEST,r),t=r;break}case"display_data":{const r=e.bundle??{data:{},metadata:{},transient:{}};super.emit(c.z.DISPLAY_DATA,r),t=r;break}case"update_display_data":{const r=e.bundle??{data:{},metadata:{},transient:{}};super.emit(c.z.UPDATE_DISPLAY_DATA,r),t=r;break}case"clear_output":{const r=e.bundle??{wait:!1};super.emit(c.z.CLEAR_OUTPUT,r),t=r;break}case"execute_result":{const r=e.bundle??{execution_count:this.executionCount,data:{},metadata:{}};super.emit(c.z.EXECUTE_RESULT,r),t=r;break}case"execute_error":{const r=e.bundle??{ename:"",evalue:"",traceback:[]};super.emit(c.z.EXECUTE_ERROR,r),t=r;break}case"comm_open":case"comm_msg":case"comm_close":{const r=e.content??{};super.emit(e.type,r,e.metadata,e.buffers),t={content:r,metadata:e.metadata,buffers:e.buffers};break}}t&&super.emit(c.z.ALL,{type:e.type,data:t})}isInitialized(){return this.initialized}async setup(e){await this.initialize(),this._parent_header=this.pyodide.toPy(e||{})}async execute(e,t={}){const r=[];try{for await(const n of this.executeStream(e,t))r.push(n);const n={outputs:[],data:{},metadata:{},execution_count:this.executionCount};for(const e of r)if("stream"===e.type)n.stdout||(n.stdout=""),n.stderr||(n.stderr=""),"stdout"===e.data.name?n.stdout+=e.data.text:"stderr"===e.data.name&&(n.stderr+=e.data.text),n.outputs.push(e.data);else if("display_data"===e.type||"execute_result"===e.type)e.data.data&&Object.assign(n.data,e.data.data),e.data.metadata&&Object.assign(n.metadata,e.data.metadata),n.outputs.push(e.data);else{if("execute_error"===e.type||"error"===e.type){const t=e.data;return{success:!1,error:new Error(`${t.ename}: ${t.evalue}`),ename:t.ename,evalue:t.evalue,traceback:t.traceback,outputs:n.outputs}}n.outputs.push(e)}return n.success=!0,this.autoSyncFs&&await this.syncAllNativeFs(),n}catch(e){return console.error("[KERNEL] Execute error:",e),{success:!1,error:e instanceof Error?e:new Error(String(e))}}}formatResult(e){if(!(e instanceof this.pyodide.ffi.PyProxy))return e;try{const t=e.toJs();return this.mapToObject(t)}catch(e){return console.error("Error formatting result:",e),{status:"error",error:String(e)}}}mapToObject(e){const t=e instanceof Array?[]:{};return e.forEach((e,r)=>{t[r]=e instanceof Map||e instanceof Array?this.mapToObject(e):e}),t}async inputReply(e){this._resolveInputReply&&(this._resolveInputReply(e),this._resolveInputReply=null)}async sendInputRequest(e,t){const r={prompt:e,password:t};this._sendMessage({type:"input_request",content:r,parentHeader:this.formatResult(this._parent_header).header})}async getpass(e){e=void 0===e?"":e,await this.sendInputRequest(e,!0);const t=new Promise(e=>{this._resolveInputReply=e});return(await t).value}async input(e){e=void 0===e?"":e,await this.sendInputRequest(e,!1);const t=new Promise(e=>{this._resolveInputReply=e});return(await t).value}async sendComm(e,t,r,n,s){this._sendMessage({type:e,content:this.formatResult(t),metadata:this.formatResult(r),ident:this.formatResult(n),buffers:this.formatResult(s),parentHeader:this.formatResult(this._parent_header).header})}async complete(e,t,r={}){await this.setup(r);const n=this._kernel.complete(e,t);return this.formatResult(n)}async inspect(e,t,r,n={}){await this.setup(n);const s=this._kernel.inspect(e,t,r);return this.formatResult(s)}async isComplete(e,t={}){await this.setup(t);const r=this._kernel.is_complete(e);return this.formatResult(r)}async commInfo(e,t={}){await this.setup(t);const r=this._kernel.comm_info(e);return{comms:this.formatResult(r),status:"ok"}}async commOpen(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_open(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async commMsg(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async commClose(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_close(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async*executeStream(e,t={}){this.initialized||await this.initialize();try{this._status="busy",super.emit(c.z.KERNEL_BUSY,{}),await this.setup(t);const r=[];let n=!1,s=null,o=null;const i=e=>{r.push(e)};super.on(c.z.ALL,i);try{for(this._kernel.run(e).then(e=>{console.log("[KERNEL] Python execution finished"),s=this.formatResult(e),s&&"error"===s.status&&(console.log("[KERNEL] Execution completed with error status, emitting execute_error event"),this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:{ename:s.ename||"Error",evalue:s.evalue||"Unknown error",traceback:s.traceback||[]},type:"execute_error"})),setTimeout(()=>{n=!0},100)}).catch(e=>{console.error("[KERNEL] Python execution error:",e),o=e instanceof Error?e:new Error(String(e)),setTimeout(()=>{n=!0},100)});!n||r.length>0;)if(r.length>0){const e=r.shift();yield e}else n||await new Promise(e=>setTimeout(e,10));if(this._status="active",super.emit(c.z.KERNEL_IDLE,{}),o)return{success:!1,error:o,result:s};if(s&&"error"===s.status){const e=`${s.ename||"Error"}: ${s.evalue||"Unknown error"}`;return{success:!1,error:new Error(e),result:s}}return this.autoSyncFs&&await this.syncAllNativeFs(),{success:!0,result:s}}finally{super.off(c.z.ALL,i)}}catch(e){return console.error("[KERNEL] ExecuteStream error:",e),this._status="active",super.emit(c.z.KERNEL_IDLE,{}),{success:!1,error:e instanceof Error?e:new Error(String(e))}}}async interrupt(){if(!this.initialized||!this.pyodide)return console.warn("[KERNEL] Cannot interrupt: kernel not initialized"),!1;console.log("[KERNEL] Attempting to interrupt execution...");try{if(this._interruptBuffer&&this._interruptSupported&&(console.log("[KERNEL] Using interrupt buffer method"),this._interruptBuffer[0]=2,await new Promise(e=>setTimeout(e,100)),0===this._interruptBuffer[0]))return console.log("[KERNEL] Interrupt processed successfully via buffer"),!0;try{return console.log("[KERNEL] Attempting Python-level interrupt"),await this.pyodide.runPythonAsync("\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n"),console.log("[KERNEL] Python interrupt signal sent"),!0}catch(e){console.log("[KERNEL] Python interrupt attempt failed:",e)}return this._interpreter&&"function"==typeof this._interpreter.interrupt?(console.log("[KERNEL] Using interpreter interrupt method"),this._interpreter.interrupt(),!0):(console.log("[KERNEL] Sending interrupt messages for UI feedback"),this._sendMessage({type:"stream",bundle:{name:"stderr",text:"KeyboardInterrupt: Execution interrupted by user\n"}}),this._sendMessage({type:"execute_error",bundle:{ename:"KeyboardInterrupt",evalue:"Execution interrupted by user",traceback:["KeyboardInterrupt: Execution interrupted by user"]}}),!1)}catch(e){return console.error("[KERNEL] Error during interrupt:",e),!1}}setInterruptBuffer(e){this._interruptBuffer=e;try{this.pyodide&&"function"==typeof this.pyodide.setInterruptBuffer?(this.pyodide.setInterruptBuffer(e),this._interruptSupported=!0):(console.warn("[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited"),this._interruptSupported=!1)}catch(e){console.error("[KERNEL] Error setting interrupt buffer:",e),this._interruptSupported=!1}}async verifyPermission(e,t){const r={};if("readwrite"===t&&(r.mode="readwrite"),console.log(`[KERNEL] Verifying ${t} permission for file handle...`),"function"!=typeof e.queryPermission)return console.warn("[KERNEL] queryPermission not supported, assuming permission granted"),!0;try{const n=await e.queryPermission(r);if(console.log("[KERNEL] Query result:",n),"granted"===n)return console.log(`[KERNEL] Permission already granted for ${t} access`),!0;if("function"==typeof e.requestPermission){console.log(`[KERNEL] Requesting ${t} permission from user...`);try{const n=await e.requestPermission(r);if(console.log("[KERNEL] Request result:",n),"granted"===n)return console.log(`[KERNEL] Permission granted for ${t} access`),!0}catch(e){console.log("[KERNEL] Permission request failed or was dismissed:",e)}}return console.log(`[KERNEL] ${t} permission not granted`),!1}catch(e){return console.error("[KERNEL] Error checking permission:",e),console.warn("[KERNEL] Permission check failed, assuming granted as fallback"),!0}}async mountFS(e,t,r="read"){if(!this.initialized||!this.pyodide)throw new Error("Kernel must be initialized before mounting filesystem");if("function"!=typeof this.pyodide.mountNativeFS)throw new Error("pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.");let n=t;if(!n){if("undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope)throw new Error("Cannot show directory picker in worker context. Please provide a dirHandle parameter.");if("undefined"==typeof window||!("showDirectoryPicker"in window))throw new Error("showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.");try{n=await window.showDirectoryPicker({mode:"readwrite"})}catch(e){throw new Error(`Failed to show directory picker: ${e instanceof Error?e.message:String(e)}`)}}if(!n)throw new Error("No directory handle available");if(console.log(`[KERNEL] Verifying ${r} permissions before mounting...`),!await this.verifyPermission(n,r))throw"readwrite"===r?new Error("Failed to obtain write permission for directory. The browser may only be offering read permission. Try mounting with permission: 'read' if you only need to read files, or ensure the browser supports write access to this directory."):new Error(`Failed to obtain ${r} permission for directory.`);const s=r;try{console.log(`[KERNEL] Mounting native filesystem at ${e} with ${s} permission`);try{if(this.pyodide.FS.analyzePath(e).exists){console.log(`[KERNEL] Path ${e} exists, checking if it's a mount point`);try{await this.pyodide.FS.unmount(e),console.log(`[KERNEL] Successfully unmounted existing filesystem at ${e}`)}catch(e){console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${e}`)}try{this.pyodide.FS.rmdir(e),console.log(`[KERNEL] Removed existing directory at ${e}`)}catch(e){console.log(`[KERNEL] Could not remove directory (this is normal): ${e}`)}}}catch(e){console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${e}`)}const t=e.substring(0,e.lastIndexOf("/"))||"/";try{"/"===t||this.pyodide.FS.analyzePath(t).exists||(this.pyodide.FS.mkdir(t),console.log(`[KERNEL] Created parent directory ${t}`))}catch(e){console.log(`[KERNEL] Parent directory handling: ${e}`)}const r=await this.pyodide.mountNativeFS(e,n);console.log(`[KERNEL] Successfully mounted native filesystem at ${e} with ${s} permission`);const o={syncfs:async()=>{if("read"===s)throw new Error(`Cannot sync read-only filesystem at ${e}. Use upgradeFileSystemPermission() to request write access.`);try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},dirHandle:n,permission:s,nativefs:r};return this.nativeFsHandles.set(e,o),{syncfs:o.syncfs}}catch(e){throw new Error(`Failed to mount native filesystem: ${e instanceof Error?e.message:String(e)}`)}}async syncAllNativeFs(){if(0===this.nativeFsHandles.size)return;const e=[];for(const[t,r]of this.nativeFsHandles.entries())if("read"!==r.permission)try{await r.syncfs(),e.push({mountPath:t,success:!0}),console.log(`[KERNEL] Successfully synced filesystem at ${t}`)}catch(n){const s=n instanceof Error?n.message:String(n);if(s.includes("not allowed by the user agent")||s.includes("getFileHandle")||s.includes("permission")){console.warn(`[KERNEL] Permission error syncing ${t}, attempting recovery...`);try{if(await this.verifyPermission(r.dirHandle,r.permission)){console.log(`[KERNEL] Permission recovered for ${t}, attempting remount...`);const n=await this.pyodide.mountNativeFS(t,r.dirHandle);r.nativefs=n,r.syncfs=async()=>{try{await n.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${t}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},await r.syncfs(),e.push({mountPath:t,success:!0}),console.log(`[KERNEL] Successfully recovered and synced filesystem at ${t}`)}else e.push({mountPath:t,success:!1,error:"Permission denied by user"}),console.warn(`[KERNEL] User denied permission for ${t}, skipping sync`)}catch(r){const n=r instanceof Error?r.message:String(r);e.push({mountPath:t,success:!1,error:`Recovery failed: ${n}`}),console.error(`[KERNEL] Failed to recover permissions for ${t}:`,r)}}else e.push({mountPath:t,success:!1,error:s}),console.error(`[KERNEL] Non-permission error syncing ${t}:`,n)}else e.push({mountPath:t,success:!0,skipped:!0}),console.log(`[KERNEL] Skipping sync for read-only filesystem at ${t}`);const t=e.filter(e=>e.success&&!e.skipped).length,r=e.filter(e=>e.skipped).length,n=e.filter(e=>!e.success);if(t>0||r>0){const n=[];t>0&&n.push(`${t} synced`),r>0&&n.push(`${r} read-only skipped`),console.log(`[KERNEL] Auto-sync completed: ${n.join(", ")} (${e.length} total filesystems)`)}n.length>0&&console.warn("[KERNEL] Auto-sync issues:",n.map(e=>`${e.mountPath}: ${e.error}`))}getMountedFileSystems(){const e=[];for(const[t,r]of this.nativeFsHandles.entries())e.push({mountPath:t,permission:r.permission,canSync:"readwrite"===r.permission});return e}async syncFileSystem(e){const t=this.nativeFsHandles.get(e);if(!t)return{success:!1,error:`No filesystem mounted at ${e}`};if("read"===t.permission)return{success:!1,error:`Cannot sync read-only filesystem at ${e}. Mount with 'readwrite' permission to enable syncing.`};try{return await t.syncfs(),{success:!0}}catch(r){const n=r instanceof Error?r.message:String(r);if(n.includes("not allowed by the user agent")||n.includes("getFileHandle")||n.includes("permission")){console.log(`[KERNEL] Permission error syncing ${e}, attempting recovery...`);try{if(await this.verifyPermission(t.dirHandle,t.permission)){const r=await this.pyodide.mountNativeFS(e,t.dirHandle);return t.nativefs=r,t.syncfs=async()=>{try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},await t.syncfs(),{success:!0}}return{success:!1,error:"Permission denied by user"}}catch(e){return{success:!1,error:`Recovery failed: ${e instanceof Error?e.message:String(e)}`}}}return{success:!1,error:n}}}async upgradeFileSystemPermission(e){const t=this.nativeFsHandles.get(e);if(!t)return{success:!1,error:`No filesystem mounted at ${e}`};if("readwrite"===t.permission)return{success:!0,error:`FileSystem at ${e} already has readwrite permission`};try{if(console.log(`[KERNEL] Attempting to upgrade ${e} to readwrite permission...`),!await this.verifyPermission(t.dirHandle,"readwrite"))return{success:!1,error:"User denied write permission or browser does not support write access to this directory"};const r=await this.pyodide.mountNativeFS(e,t.dirHandle);return t.permission="readwrite",t.nativefs=r,t.syncfs=async()=>{try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},console.log(`[KERNEL] Successfully upgraded ${e} to readwrite permission`),{success:!0}}catch(e){return{success:!1,error:`Failed to upgrade permission: ${e instanceof Error?e.message:String(e)}`}}}async setEnvironmentVariables(){if(0===Object.keys(this.environmentVariables).length)return;const e=Date.now();console.log(`ðŸŒ Setting ${Object.keys(this.environmentVariables).length} environment variables...`);try{for(const[e,t]of Object.entries(this.environmentVariables)){let r;r=null==t?"":String(t),await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(e)}] = ${JSON.stringify(r)}\n`)}const t=Date.now()-e;console.log(`âš¡ Environment variables set in ${t}ms`)}catch(e){throw console.error("âŒ Failed to set environment variables:",e),e}}}},696:(e,t,r)=>{var n;r.d(t,{z:()=>n}),function(e){e.STREAM="stream",e.DISPLAY_DATA="display_data",e.UPDATE_DISPLAY_DATA="update_display_data",e.EXECUTE_RESULT="execute_result",e.EXECUTE_ERROR="execute_error",e.EXECUTE_REQUEST="execute_request",e.INPUT_REQUEST="input_request",e.CLEAR_OUTPUT="clear_output",e.COMM_OPEN="comm_open",e.COMM_MSG="comm_msg",e.COMM_CLOSE="comm_close",e.KERNEL_READY="kernel_ready",e.KERNEL_BUSY="kernel_busy",e.KERNEL_IDLE="kernel_idle",e.ALL="*",e.EXECUTION_STALLED="execution_stalled",e.KERNEL_UNRECOVERABLE="kernel_unrecoverable",e.EXECUTION_INTERRUPTED="execution_interrupted",e.KERNEL_RESTARTED="kernel_restarted",e.KERNEL_TERMINATED="kernel_terminated"}(n||(n={}))}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var n=r(590),s=r(696);const o=new(r(637).MB);let i=null,a={},c=new Map,l=null;function u(e){return e&&"object"==typeof e&&("KeyboardInterrupt"===e.type||e.message&&e.message.includes("KeyboardInterrupt"))}function p(){i?Object.values(s.z).forEach(e=>{const t=t=>{i&&i.postMessage({type:e,data:t})};c.set(e,t),o.on(e,t)}):console.error("[WORKER] Cannot set up event forwarding: no event port available")}self.addEventListener("error",e=>{console.error("[WORKER] Global error caught:",e.error),e.preventDefault()}),self.addEventListener("unhandledrejection",e=>{u(e.reason)?(console.log("[WORKER] KeyboardInterrupt caught in unhandled rejection handler - this is expected during interrupts"),i&&i.postMessage({type:s.z.EXECUTE_ERROR,data:{ename:"KeyboardInterrupt",evalue:"Execution interrupted by user",traceback:["KeyboardInterrupt: Execution interrupted by user"]}})):console.error("[WORKER] Unhandled promise rejection:",e.reason),e.preventDefault()}),self.addEventListener("message",e=>{if("SET_EVENT_PORT"===e.data?.type&&e.data?.port)!function(){if(c.size>0){for(const[e,t]of c.entries())o.off(e,t);c.clear()}i&&(i.close(),i=null)}(),i=e.data.port,o.isInitialized()&&p();else if("INITIALIZE_KERNEL"===e.data?.type)a=e.data.options||{},async function(e){try{await o.initialize(e),l&&"function"==typeof o.setInterruptBuffer&&o.setInterruptBuffer(l),p(),i&&i.postMessage({type:"KERNEL_INITIALIZED",data:{success:!0}})}catch(e){throw console.error("Kernel initialization failed:",e),e}}(a).catch(e=>{console.error("[WORKER] Error initializing kernel in worker:",e),i&&i.postMessage({type:s.z.EXECUTE_ERROR,data:{ename:"WorkerInitError",evalue:`Failed to initialize kernel: ${e.message}`,traceback:[e.stack||""]}})});else if("SET_INTERRUPT_BUFFER"===e.data?.type){l=e.data.buffer,o.isInitialized()&&l&&"function"==typeof o.setInterruptBuffer?(o.setInterruptBuffer(l),console.log("[WORKER] Interrupt buffer set in pyodide kernel")):l&&console.log("[WORKER] Interrupt buffer stored, will be set when kernel initializes");const t={type:"INTERRUPT_BUFFER_SET",data:{success:!0}};i&&i.postMessage(t),self.postMessage(t)}else if("INTERRUPT_KERNEL"===e.data?.type)if(l){l[0]=2;const e={type:"INTERRUPT_TRIGGERED",data:{success:!0,method:"buffer"}};i&&i.postMessage(e),self.postMessage(e)}else if(console.log("[WORKER] No interrupt buffer available, trying kernel.interrupt()"),"function"==typeof o.interrupt)o.interrupt().then(e=>{const t={type:"INTERRUPT_TRIGGERED",data:{success:e,method:"kernel"}};i&&i.postMessage(t),self.postMessage(t)}).catch(e=>{console.error("[WORKER] Error during kernel interrupt:",e);const t={type:"INTERRUPT_TRIGGERED",data:{success:!1,error:e.message,method:"kernel"}};i&&i.postMessage(t),self.postMessage(t)});else{console.warn("[WORKER] No interrupt method available");const e={type:"INTERRUPT_TRIGGERED",data:{success:!1,error:"No interrupt method available",method:"none"}};i&&i.postMessage(e),self.postMessage(e)}}),self.addEventListener("beforeunload",async()=>{try{i&&i.postMessage({type:"WORKER_TERMINATING",data:{message:"Worker is shutting down"}})}catch(e){console.error("Error during worker cleanup:",e)}});const d={initialize:async e=>{try{return void await o.initialize(e)}catch(e){throw console.error("[WORKER] Initialize error:",e),e}},execute:async(e,t)=>{try{return await o.execute(e,t)}catch(e){return console.error("[WORKER] Execute error:",e),u(e)?(console.log("[WORKER] KeyboardInterrupt caught in execute method"),{success:!1,error:new Error("KeyboardInterrupt: Execution interrupted by user"),result:{payload:[],status:"error",ename:"KeyboardInterrupt",evalue:"Execution interrupted by user",traceback:["KeyboardInterrupt: Execution interrupted by user"]}}):{success:!1,error:e instanceof Error?e:new Error(String(e)),result:{payload:[],status:"error",ename:e instanceof Error?e.constructor.name:"Error",evalue:e instanceof Error?e.message:String(e),traceback:e instanceof Error&&e.stack?e.stack.split("\n"):[String(e)]}}}},isInitialized:()=>{try{return o.isInitialized()}catch(e){return console.error("[WORKER] IsInitialized error:",e),!1}},inputReply:async e=>{try{await o.inputReply(e)}catch(e){throw console.error("[WORKER] InputReply error:",e),e}},getStatus:async()=>{try{return await o.getStatus()}catch(e){return console.error("[WORKER] getStatus error:",e),"unknown"}},interrupt:async()=>{try{return"function"==typeof o.interrupt?await o.interrupt():(console.warn("[WORKER] Kernel does not support interrupt method"),!1)}catch(e){return console.error("[WORKER] Interrupt error:",e),!1}},setInterruptBuffer:e=>{try{return"function"==typeof o.setInterruptBuffer?(o.setInterruptBuffer(e),!0):(console.warn("[WORKER] Kernel does not support setInterruptBuffer method"),!1)}catch(e){return console.error("[WORKER] setInterruptBuffer error:",e),!1}},complete:async(e,t,r)=>{try{return"function"==typeof o.complete?await o.complete(e,t,r):(console.warn("[WORKER] Kernel does not support complete method"),{status:"error",error:"Completion not supported"})}catch(e){return console.error("[WORKER] Complete error:",e),{status:"error",error:String(e)}}},inspect:async(e,t,r,n)=>{try{return"function"==typeof o.inspect?await o.inspect(e,t,r,n):(console.warn("[WORKER] Kernel does not support inspect method"),{status:"error",error:"Inspection not supported"})}catch(e){return console.error("[WORKER] Inspect error:",e),{status:"error",error:String(e)}}},isComplete:async(e,t)=>{try{return"function"==typeof o.isComplete?await o.isComplete(e,t):(console.warn("[WORKER] Kernel does not support isComplete method"),{status:"unknown"})}catch(e){return console.error("[WORKER] IsComplete error:",e),{status:"error",error:String(e)}}},mountFS:async(e,t,r)=>{try{if("function"==typeof o.mountFS){if(!t)throw new Error("Cannot show directory picker in worker context. Please provide a dirHandle parameter when calling mountFS on a worker kernel.");const s=await o.mountFS(e,t,r);return n.BX(s)}throw console.warn("[WORKER] Kernel does not support mountFS method"),new Error("mountFS is not supported by this kernel")}catch(e){throw console.error("[WORKER] MountFS error:",e),e}},getMountedFileSystems:async()=>{try{return"function"==typeof o.getMountedFileSystems?o.getMountedFileSystems():(console.warn("[WORKER] Kernel does not support getMountedFileSystems method"),[])}catch(e){return console.error("[WORKER] getMountedFileSystems error:",e),[]}},syncFileSystem:async e=>{try{return"function"==typeof o.syncFileSystem?await o.syncFileSystem(e):(console.warn("[WORKER] Kernel does not support syncFileSystem method"),{success:!1,error:"syncFileSystem is not supported by this kernel"})}catch(e){return console.error("[WORKER] syncFileSystem error:",e),{success:!1,error:e instanceof Error?e.message:String(e)}}},upgradeFileSystemPermission:async e=>{try{return"function"==typeof o.upgradeFileSystemPermission?await o.upgradeFileSystemPermission(e):(console.warn("[WORKER] Kernel does not support upgradeFileSystemPermission method"),{success:!1,error:"upgradeFileSystemPermission is not supported by this kernel"})}catch(e){return console.error("[WORKER] upgradeFileSystemPermission error:",e),{success:!1,error:e instanceof Error?e.message:String(e)}}},commInfo:async(e,t)=>{try{return"function"==typeof o.commInfo?await o.commInfo(e,t):(console.warn("[WORKER] Kernel does not support commInfo method"),{comms:{},status:"ok"})}catch(e){return console.error("[WORKER] CommInfo error:",e),{comms:{},status:"error",error:String(e)}}},commOpen:async(e,t)=>{try{return"function"==typeof o.commOpen?await o.commOpen(e,t):void console.warn("[WORKER] Kernel does not support commOpen method")}catch(e){return void console.error("[WORKER] CommOpen error:",e)}},commMsg:async(e,t)=>{try{return"function"==typeof o.commMsg?await o.commMsg(e,t):void console.warn("[WORKER] Kernel does not support commMsg method")}catch(e){return void console.error("[WORKER] CommMsg error:",e)}},commClose:async(e,t)=>{try{return"function"==typeof o.commClose?await o.commClose(e,t):void console.warn("[WORKER] Kernel does not support commClose method")}catch(e){return void console.error("[WORKER] CommClose error:",e)}}};try{n.p(d)}catch(e){console.error("Error exposing proxy:",e)}
//# sourceMappingURL=kernel.worker.min.js.map